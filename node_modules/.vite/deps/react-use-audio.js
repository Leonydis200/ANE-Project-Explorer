import {
  __toESM,
  require_react
} from "./chunk-N6MYFXC3.js";

// node_modules/react-use-audio/dist/index.js
var import_react = __toESM(require_react());
var u = Object.defineProperty;
var d = (i, e, s) => e in i ? u(i, e, { enumerable: true, configurable: true, writable: true, value: s }) : i[e] = s;
var t = (i, e, s) => (d(i, typeof e != "symbol" ? e + "" : e, s), s);
var f = class {
  constructor() {
    t(this, "listeners");
    t(this, "audioContext");
    t(this, "audioBuffer");
    t(this, "audioBufferSourceNode");
    t(this, "snapshot");
    t(this, "updateAudioData", (e) => {
      const s = this.snapshot.data;
      this.snapshot = {
        ...this.snapshot,
        data: { ...s, ...e }
      }, this.emitChange();
    });
    t(this, "resetAudio", () => {
      this.updateAudioData({ isPlaying: false, isPause: false });
    });
    t(this, "playAudio", () => {
      const e = this.audioContext.createBufferSource();
      e.buffer = this.audioBuffer, e.connect(this.audioContext.destination), e.start(), this.audioBufferSourceNode = e, this.audioBufferSourceNode.addEventListener("ended", this.resetAudio);
    });
    t(this, "play", () => {
      switch (this.audioContext.state !== "suspended" && !this.snapshot.data.isPause && this.audioBufferSourceNode.removeEventListener("ended", this.resetAudio), this.audioContext.state) {
        case "closed": {
          this.audioContext = new AudioContext(), this.playAudio(), this.updateAudioData({
            isPause: false,
            isPlaying: true,
            audioBufferSourceNode: this.audioBufferSourceNode
          });
          break;
        }
        case "suspended": {
          this.audioContext.resume(), this.snapshot.data.isPause ? this.updateAudioData({
            isPause: false,
            isPlaying: true,
            audioBufferSourceNode: this.audioBufferSourceNode
          }) : (this.playAudio(), this.updateAudioData({
            isPause: false,
            isPlaying: true,
            audioBufferSourceNode: this.audioBufferSourceNode
          }));
          break;
        }
        case "running": {
          this.playAudio(), this.updateAudioData({
            isPause: false,
            isPlaying: true,
            audioBufferSourceNode: this.audioBufferSourceNode
          });
          break;
        }
      }
    });
    t(this, "stop", () => {
      this.audioContext.state === "running" && this.snapshot.data.isPlaying && this.audioBufferSourceNode.stop(), this.audioContext.state !== "closed" && this.audioContext.close(), this.audioBufferSourceNode.disconnect(), this.updateAudioData({ isPause: false, isPlaying: false });
    });
    t(this, "pause", () => {
      this.audioContext.state === "running" && this.snapshot.data.isPlaying && this.audioContext.suspend(), this.updateAudioData({
        isPlaying: false,
        isPause: true
      });
    });
    t(this, "subscribe", (e, s) => (this.listeners.add(e), this.updateAudioData({ name: s }), fetch(s).then((o) => o.arrayBuffer()).then((o) => this.audioContext.decodeAudioData(o)).then((o) => this.audioBuffer = o).then(this.emitChange).catch((o) => console.error(o.message)), () => {
      this.listeners.delete(e), this.audioBufferSourceNode.disconnect(), this.audioContext.state !== "closed" && this.audioContext.close(), this.audioContext = new AudioContext(), this.audioBufferSourceNode = this.audioContext.createBufferSource(), this.audioBuffer = null, this.updateAudioData({
        name: "",
        isPause: false,
        isPlaying: false,
        audioBufferSourceNode: this.audioBufferSourceNode
      }), this.audioBufferSourceNode.removeEventListener("ended", this.resetAudio);
    }));
    t(this, "getSnapshot", () => this.snapshot);
    t(this, "emitChange", () => {
      this.listeners.forEach((e) => e());
    });
    this.listeners = /* @__PURE__ */ new Set(), this.audioContext = new AudioContext(), this.audioBufferSourceNode = this.audioContext.createBufferSource(), this.audioBuffer = null, this.snapshot = {
      data: {
        isPlaying: false,
        isPause: false,
        name: "",
        audioBufferSourceNode: this.audioBufferSourceNode
      },
      play: this.play,
      stop: this.stop,
      pause: this.pause
    };
  }
};
var p = (i) => {
  const e = (0, import_react.useRef)(null);
  e.current === null && (e.current = new f());
  const s = (0, import_react.useCallback)(
    (a) => (
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      e.current.subscribe(a, i)
    ),
    [i]
  );
  return (0, import_react.useSyncExternalStore)(
    s,
    e == null ? void 0 : e.current.getSnapshot
  );
};
export {
  f as AudioController,
  p as useAudio
};
//# sourceMappingURL=react-use-audio.js.map
