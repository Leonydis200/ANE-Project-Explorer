var u = Object.defineProperty;
var d = (i, e, s) => e in i ? u(i, e, { enumerable: !0, configurable: !0, writable: !0, value: s }) : i[e] = s;
var t = (i, e, s) => (d(i, typeof e != "symbol" ? e + "" : e, s), s);
import { useRef as r, useCallback as n, useSyncExternalStore as h } from "react";
class f {
  constructor() {
    t(this, "listeners");
    t(this, "audioContext");
    t(this, "audioBuffer");
    t(this, "audioBufferSourceNode");
    t(this, "snapshot");
    t(this, "updateAudioData", (e) => {
      const s = this.snapshot.data;
      this.snapshot = {
        ...this.snapshot,
        data: { ...s, ...e }
      }, this.emitChange();
    });
    t(this, "resetAudio", () => {
      this.updateAudioData({ isPlaying: !1, isPause: !1 });
    });
    t(this, "playAudio", () => {
      const e = this.audioContext.createBufferSource();
      e.buffer = this.audioBuffer, e.connect(this.audioContext.destination), e.start(), this.audioBufferSourceNode = e, this.audioBufferSourceNode.addEventListener("ended", this.resetAudio);
    });
    t(this, "play", () => {
      switch (this.audioContext.state !== "suspended" && !this.snapshot.data.isPause && this.audioBufferSourceNode.removeEventListener("ended", this.resetAudio), this.audioContext.state) {
        case "closed": {
          this.audioContext = new AudioContext(), this.playAudio(), this.updateAudioData({
            isPause: !1,
            isPlaying: !0,
            audioBufferSourceNode: this.audioBufferSourceNode
          });
          break;
        }
        case "suspended": {
          this.audioContext.resume(), this.snapshot.data.isPause ? this.updateAudioData({
            isPause: !1,
            isPlaying: !0,
            audioBufferSourceNode: this.audioBufferSourceNode
          }) : (this.playAudio(), this.updateAudioData({
            isPause: !1,
            isPlaying: !0,
            audioBufferSourceNode: this.audioBufferSourceNode
          }));
          break;
        }
        case "running": {
          this.playAudio(), this.updateAudioData({
            isPause: !1,
            isPlaying: !0,
            audioBufferSourceNode: this.audioBufferSourceNode
          });
          break;
        }
      }
    });
    t(this, "stop", () => {
      this.audioContext.state === "running" && this.snapshot.data.isPlaying && this.audioBufferSourceNode.stop(), this.audioContext.state !== "closed" && this.audioContext.close(), this.audioBufferSourceNode.disconnect(), this.updateAudioData({ isPause: !1, isPlaying: !1 });
    });
    t(this, "pause", () => {
      this.audioContext.state === "running" && this.snapshot.data.isPlaying && this.audioContext.suspend(), this.updateAudioData({
        isPlaying: !1,
        isPause: !0
      });
    });
    t(this, "subscribe", (e, s) => (this.listeners.add(e), this.updateAudioData({ name: s }), fetch(s).then((o) => o.arrayBuffer()).then((o) => this.audioContext.decodeAudioData(o)).then((o) => this.audioBuffer = o).then(this.emitChange).catch((o) => console.error(o.message)), () => {
      this.listeners.delete(e), this.audioBufferSourceNode.disconnect(), this.audioContext.state !== "closed" && this.audioContext.close(), this.audioContext = new AudioContext(), this.audioBufferSourceNode = this.audioContext.createBufferSource(), this.audioBuffer = null, this.updateAudioData({
        name: "",
        isPause: !1,
        isPlaying: !1,
        audioBufferSourceNode: this.audioBufferSourceNode
      }), this.audioBufferSourceNode.removeEventListener("ended", this.resetAudio);
    }));
    t(this, "getSnapshot", () => this.snapshot);
    t(this, "emitChange", () => {
      this.listeners.forEach((e) => e());
    });
    this.listeners = /* @__PURE__ */ new Set(), this.audioContext = new AudioContext(), this.audioBufferSourceNode = this.audioContext.createBufferSource(), this.audioBuffer = null, this.snapshot = {
      data: {
        isPlaying: !1,
        isPause: !1,
        name: "",
        audioBufferSourceNode: this.audioBufferSourceNode
      },
      play: this.play,
      stop: this.stop,
      pause: this.pause
    };
  }
}
const p = (i) => {
  const e = r(null);
  e.current === null && (e.current = new f());
  const s = n(
    (a) => (
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      e.current.subscribe(a, i)
    ),
    [i]
  );
  return h(
    s,
    e == null ? void 0 : e.current.getSnapshot
  );
};
export {
  f as AudioController,
  p as useAudio
};
